from textwrap import dedent, indent
from typing import Tuple, Dict
from pathlib import Path

class GenerateAst:
    def __init__(self, output_path: Path, base_class: str, inheritors: Dict[str, Tuple[str]]):
        self.output_path = output_path
        self.base_class = base_class
        self.inheritors = inheritors

    def define_ast(self):
        with open(self.output_path / "expr.py", "w") as f:
            # IMPORTS
            f.write("From abc import ABC, abstractmethod")

            # VISITOR BASE CLASS


            # BASE CLASS DEF
            f.write("# Auto Generated by tools/generate_ast.py")
            f.write(dedent("""
                class Expr(ABC):
                    @abstractmethod
                    def accept(self, visitor):
                        pass
                """
            ))

            for key, value in self.inheritors.items():
                f.write(self.return_inheritor(key, value))

    def return_visitor(self, class_name: str):
        pass

    def return_inheritor(self, class_name: str, parameters: Tuple[str]) -> str:
        init_params = ", ".join(parameters)
        assignments = "\n".join([f"self.{p} = {p}" for p in parameters])
        body = indent(assignments, "        ")

        class_def = dedent(f"""
            # Define {class_name}
            class {class_name}({self.base_class}):
                def __init__(self, {init_params}):
            """).strip()

        return f"\n{class_def}\n{body}\n"


# if __name__ == '__main__':
#
#     ast_definitions = {
#         "BinaryExpr"    : ("expr_left", "operator", "expr_right"),
#         "UnaryExpr"     : ("operator", "expr_right"),
#         "GroupExpr"     : ("expr",),
#         "LiteralExpr"   : ("value",),
#     }
#
#     test = GenerateAst(Path(""), "Expr", ast_definitions)
#     test.define_ast()
